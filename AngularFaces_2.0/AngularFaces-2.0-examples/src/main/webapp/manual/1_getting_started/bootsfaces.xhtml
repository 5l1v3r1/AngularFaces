<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" 
      xmlns:h="http://java.sun.com/jsf/html" 
      xmlns:f="http://java.sun.com/jsf/core"
      xmlns:b="http://bootsfaces.net/ui" 
      xmlns:ui="http://java.sun.com/jsf/facelets" 
      xmlns:ng="http://xmlns.jcp.org/jsf/passthrough"
      xmlns:jsf="http://xmlns.jcp.org/jsf"
      xmlns:ac="http://beyondjava.net/angularFacesCore">

<h:head> </h:head>
<h:body >
  <ui:composition template="../../menu/index.xhtml">
    <ui:define name="content">
       <div id="angular">
	      <h:form>
	        <section>
	            <b:tabView>
		            <b:tab title="live demo">
						<div ng-app="AngularFacesExamples" ng-controller="MyCtrl" id="angular" ng-cloak="ng-cloak">
						  <div id="myForm">
						    <ac:updateModelAfterAJAXRequest />
							<h2>Welcome to AngularFaces 2.0!</h2>
				    		Based firmly in the future...<br />
				    		<b:panel title="{{calculatorBean.headerText}}" look="info"
								titleStyle="{{calculatorBean.gridStyle}}">
								<p>This demo uses BootsFaces.</p>
								<h:panelGrid columns="3">
										<h:inputText value="{{calculatorBean.number1}}" label="number1"/>
										<h:inputText value="{{calculatorBean.number2}}" />
										<h:inputText value="{{calculatorBean.result}}" />
										<h:inputText value="{{calculatorBean.serverSideResult}}"  />
										<h:inputText value="{{calculatorBean.randomNumberFromServer}}" id="random"  />
									<b:commandButton value="Add on server (via AF-AJAX)" ajax="true" update="angular" 
										action="#{calculatorBean.add}">
									</b:commandButton>
									<b:commandButton value="Add on server (without AJAX)" action="#{calculatorBean.add}" />
									<b:commandButton value="Add on server (via JSF-AJAX)" ajax="true" update="@form"
										action="#{calculatorBean.add}">
									</b:commandButton>
								</h:panelGrid>
								The update region is only a part of the DOM tree controlled by AngularJS. Therefore, you need an &lt;ac:updateModelAfterAJAXRequest /&gt; tag to update the AngularJS model after an AJAX request.
								<b:messages globalOnly="false" />
							</b:panel>
						</div>
					</div>
		           </b:tab>
	            <b:tab title="JSF markup">
<script type="syntaxhighlighter" class="brush: xml; toolbar: false;first-line: 0">
<![CDATA[
						<div ng-app="AngularFacesExamples" ng-controller="MyCtrl" id="angular" ng-cloak="ng-cloak">
						  <div id="myForm">
						    <ac:updateModelAfterAJAXRequest />
							<h2>Welcome to AngularFaces 2.0!</h2>
				    		Based firmly in the future...<br />
				    		<b:panel title="{{calculatorBean.headerText}}" look="info"
								titleStyle="{{calculatorBean.gridStyle}}">
								<p>This demo uses BootsFaces.</p>
								<h:panelGrid columns="3">
										<h:inputText value="{{calculatorBean.number1}}" label="number1"/>
										<h:inputText value="{{calculatorBean.number2}}" />
										<h:inputText value="{{calculatorBean.result}}" />
										<h:inputText value="{{calculatorBean.serverSideResult}}"  />
										<h:inputText value="{{calculatorBean.randomNumberFromServer}}" id="random"  />
									<b:commandButton value="Add on server (via AF-AJAX)" ajax="true" update="angular" 
										action="&num;{calculatorBean.add}">
									</b:commandButton>
									<b:commandButton value="Add on server (without AJAX)" action="&num;{calculatorBean.add}" />
									<b:commandButton value="Add on server (via JSF-AJAX)" ajax="true" update="@form"
										action="&num;{calculatorBean.add}">
									</b:commandButton>
								</h:panelGrid>
								The update region is only a part of the DOM tree controlled by AngularJS. Therefore, you need an &lt;ac:updateModelAfterAJAXRequest /&gt; tag to update the AngularJS model after an AJAX request.
								<b:messages globalOnly="false" />
							</b:panel>
						</div>
					</div>
]]>
</script>
	           </b:tab>
	        </b:tabView>
	        </section>
	        <br />
	        <h:messages />
	      </h:form>
	    </div>
    </ui:define>
  </ui:composition>
</h:body>
</html>
