<?xml version='1.0' encoding='UTF-8' ?>
<!DOCTYPE html>
<ui:fragment xmlns="http://www.w3.org/1999/xhtml" xmlns:h="http://java.sun.com/jsf/html" xmlns:f="http://java.sun.com/jsf/core"
  xmlns:b="http://bootsfaces.net/ui" xmlns:ui="http://java.sun.com/jsf/facelets" xmlns:ng="http://xmlns.jcp.org/jsf/passthrough"
  xmlns:ac="http://beyondjava.net/angularFacesCore">

     <b:panel title="JUA" look="primary">
      
          <h1>The AngularFaces way of doing AJAX</h1>
          <p>Most of the time AngularFaces replaces the original AJAX requests by its own, highly-optimized requests.</p>
          <p>Synchronizing values between AngularJS scope and JSF beans works in both ways. The values of the input fields are transmitted back to the
          server, no matter whether you do a regular HTML request, a JSF AJAX request or the optimized AngularFaces request.</p>
          <p>AngularFaces provides an advanced way of AJAX requests. Typically, they use a lot less network bandwidth, and they are faster than traditional
          JSF AJAX request. To activate an AngularFaces AJAX, you have to do two simple preparations:</p>
          <ul>
          <li>Add an JSF AJAX button that includes a special update region: "angular". You've already seen this above: 
<script type="syntaxhighlighter" class="brush: xml; toolbar: false;first-line: 0">
<![CDATA[
&lt;prime:commandButton value="save" update="angular" action="&#34;{customer.save}" /> ]]></script>
          </li>
          <li>Add the id "angular" to the &lt;h:body&gt;.
<script type="syntaxhighlighter" class="brush: xml; toolbar: false;first-line: 0">
<![CDATA[
&lt;h:body ng-app="AngularFacesExamples" ng-controller="MyCtrl" id="angular"><
]]></script>
          </li>
          </ul>
          <p>
          Note that the id "angular" doesn't really mark an ordinary update region. It's a virtual id. If AngularFaces sees the id, it replaces the default
          update response generated by JSF by a highly-optimized response that updates only the scope values. However, there are also drawbacks to this approach.
          For instance, the &lt;prime:growl&gt; tag isn't updated. I don't consider this a disadvantage: the idea of AngularFaces
          is to move such functionality to the client. Validation and presenting error messages in particular is Angular's job.
          </p>
          <p>Note that AngularFaces 2.1 adds special support for <code>&lt;h:messages /&gt;</code> and <code>&lt;prime:messages /&gt;</code>. Both tags
          are silently replaced by client-side widgets, and the content of these widgets is part of the AngularFaces AJAX requests.</p>
                    
          <h3>Beware of rendered="false"</h3>
          <p>
          It's a bad idea to use <code>rendered="false"</code> to hide a component in an AngularFaces page. AngularFaces uses optimized AJAX responses that update the 
          variables of the scope, but nothing else. Hence, if you show or hide something on the server side using the rendered attribute, the 
          HTML page is never updated. Better use <code>ng-show</code>, <code>ng-hide</code> or - as shown above - either <code>style</code> or <code>styleClass</code>. 
          </p>
          
          <h3>Under the hood</h3>
          This is an example of an AngularFaces AJAX response:
          <b:well>
<script type="syntaxhighlighter" class="brush: xml; toolbar: false;first-line: 0">
<![CDATA[
&lt;?xml version='1.0' encoding='UTF-8'?>
&lt;partial-response id="j_id1">
  &lt;changes>
  &lt;eval>&lt;! [CDATA[
     injectJSonIntoScope("calculatorBean",'{"result":107,
                        "randomNumberFromServer":50,
                        "number1":42,
                        "serverSideResult":107,
                        "number2":65}
                        ,window.jsfScope);
  ] ]>&lt;/eval>
  &lt;update id="j_id1:javax.faces.ViewState:0">&lt;! [CDATA[...] ]>
  &lt;/update>
  &lt;/changes>
    &lt;/partial-response>
]]></script>
</b:well>

<p>          
          Basically, the response consists of a single Javascript function that's send to the client. By contrast, a traditional JSF response replaces a part
          of the DOM tree. You can easily spot the difference, even though I've omitted a lot of the code in the example:
          </p>
          <b:well>
<script type="syntaxhighlighter" class="brush: xml; toolbar: false;first-line: 0">
<![CDATA[
&lt;?xml version='1.0' encoding='UTF-8'?>
&lt;partial-response id="j_id1">
  &lt;changes>
  &lt;update id="myForm">

&lt;form id="myForm" name="myForm" method="post"
  action="/angularfaces-examples/manual/1_getting_started/primefaces.jsf"
  enctype="application/x-www-form-urlencoded">
  &lt;input type="hidden" name="myForm" value="myForm" />

  &lt;h2>Welcome to AngularFaces 2.1!&lt;/h2>
  Based firmly in the future...
  &lt;div id="myForm:j_idt3" class="ui-panel ui-widget ui-widget-content ui-corner-all"
    data-widget="widget_myForm_j_idt3">
    &lt;div id="myForm:j_idt3_header"
      class="ui-panel-titlebar ui-widget-header ui-helper-clearfix ui-corner-all">
      &lt;span class="ui-panel-title">This is a JSF view enriched by an AngularJS bean&lt;/span>
    &lt;/div>
    &lt;div id="myForm:j_idt3_content" class="ui-panel-content ui-widget-content">
      &lt;table id="myForm:j_idt4" class="ui-panelgrid ui-widget" role="grid">
        &lt;tbody>
          &lt;tr class="ui-widget-content" role="row">
            &lt;td role="gridcell" class="ui-panelgrid-cell">
              &lt;label id="myForm:j_id8" class="ui-outputlabel ui-widget"
                for="myForm:j_idt5">
                &lt;span class="ui-outputlabel-rfi">*&lt;/span>
              &lt;/label>
            &lt;/td>
            &lt;td role="gridcell" class="ui-panelgrid-cell">
              &lt;input id="myForm:j_idt5" name="myForm:j_idt5" type="number"
                value="42" min="7" ng-model="calculatorBean.number1" max="50"
                required=""
                class="ui-inputfield ui-inputtext ui-widget ui-state-default ui-corner-all"
                data-p-label="" data-p-con="javax.faces.Integer"
                data-p-maxvalue="50" data-p-minvalue="7" data-p-required="true"
                data-p-val="NotNull,Min,Max" />
              &lt;script id="myForm:j_idt5_s" type="text/javascript">
                PrimeFaces.cw("InputText", "widget_myForm_j_idt5", {
                id : "myForm:j_idt5",
                widgetVar : "widget_myForm_j_idt5"
                });
              &lt; /script>
            &lt;/td>
            &lt;td role="gridcell" class="ui-panelgrid-cell">
              &lt;angularfacesmessage af-for="myForm:j_idt5">&lt;/angularfacesmessage>
            &lt;/td>
          &lt;/tr>
          ...
        &lt;/tbody>
      &lt;/table>
      &lt;div id="myForm:j_idt13" class="ui-messages ui-widget" aria-live="polite"
        data-summary="data-summary" data-severity="all,error">
        &lt;div class="ui-messages-info ui-corner-all">
          &lt;span class="ui-messages-info-icon">&lt;/span>
          &lt;ul>
            &lt;li>
              &lt;span class="ui-messages-info-summary">Last calculation on the server side: 42+65=107&lt;/span>
            &lt;/li>
          &lt;/ul>
        &lt;/div>
      &lt;/div>
    &lt;/div>
  &lt;/div>
  &lt;script id="myForm:j_idt3_s" type="text/javascript">
    PrimeFaces.cw("Panel", "widget_myForm_j_idt3", {
    id : "myForm:j_idt3",
    widgetVar : "widget_myForm_j_idt3"
    });
  &lt; /script>
  ...
&lt;/form>
  &lt;/update>
  &lt;update id="j_id1:javax.faces.ViewState:0">&lt;![CDATA[...] ]>
  &lt;/update>
  &lt;/changes>
&lt;/partial-response>
]]></script>
</b:well>

      </b:panel>

</ui:fragment>
