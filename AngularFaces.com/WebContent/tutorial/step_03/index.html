<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="Description"
	content="AngularFaces brings AngularJS to the JSF world">
	<title>AngularFaces 2.0 tutorial step 03 - Making JSF Input Fields "Angular"</title>
	<link rel="stylesheet" href="../../bootstrap.min.css" type="text/css">
	<script type="text/javascript" src="../../syntaxhighlighter/shCore.js"></script>
	<script type="text/javascript" src="../../syntaxhighlighter/shBrushJScript.js"></script>
	<script type="text/javascript" src="../../syntaxhighlighter/shBrushXml.js"></script>
	<script type="text/javascript" src="../../syntaxhighlighter/shBrushJava.js"></script>
	<script type="text/javascript" src="../../syntaxhighlighter/shBrushBat.js"></script>
	<link type="text/css" rel="stylesheet" href="../../syntaxhighlighter/shCoreDefault.css"/>
	<script type="text/javascript">SyntaxHighlighter.all();</script>
</head>
<body>
	<div id="wrapper">
		<header class="header header-fixed">
			<section class="navbar navbar-inverse docs-navbar-primary">
				<div class="container">
					<div class="row">
						<div class="col-md-9 header-branding">
							<ul class="nav navbar-nav">
								<li class="divider-vertical"></li>
								<li class="dropdown"><a
									href="http://angularfaces.com">What is
										AngularFaces? </a></li>
								<li class="dropdown"><a
									href="http://www.angularfaces.com/tutorial">Tutorial </a></li>
								<li class="divider-vertical"></li>
								<li><a href="http://www.beyondjava.net"><i
										class="icon-home icon-white"></i>http://BeyondJava.net</a></li>
							</ul>
						</div>
					</div>
				</div>
			</section>
		</header>
	</div>


	<section role="main" class="container main-body">
		<div class="main-grid main-body-grid">
			<div class="col-md-3">
				<div class="side-navigation">
					<ul class="nav-list naked-list">
						<li class="nav-index-group"><a
							href="/tutorial/index.html"
							class="nav-index-group-heading active">Tutorial</a>
							<ul class="aside-nav">
								<li class="nav-index-listing active"><a tabindex="2"
									href="/tutorial/step_00/index.html">0 - Bootstrapping</a></li>
								<li class="nav-index-listing active">
									<a href="/tutorial/step_01/index.html" >1 - Labels and messages</a>
								</li>
								<li class="nav-index-listing active">
									<a href="/tutorial/step_02/index.html" >2 - Foreign language support</a>
								</li>
								<li class="nav-index-listing active">
									<a href="/tutorial/step_03/index.html" >3 - Angular input fields</a>
								<li class="nav-index-listing active">
									<a href="/tutorial/step_04/index.html" >4 - Using mustaches in JSF attributes</a>
								</li>
								<li class="nav-index-listing active">
									<a href="/tutorial/step_05/index.html" >5 - Client side bean validation (JSR 303)</a>
								</li>
								<li class="nav-index-listing active">
									<a href="/tutorial/step_06/index.html" >6 - Prime:datatable vs. ngtable</a>
								</li>
								<li class="nav-index-listing active">
									<a href="/tutorial/step_07/index.html" >7 - The AngularFaces way of AJAX</a>
								</li>
								<li class="nav-index-listing active">
									<a href="/tutorial/step_08/index.html" >8 - ng* pass-through attributes</a>
								</li>
							</ul></li>
					</ul>
				</div>
			</div>
			<div class="col-md-9">
				<div>
					<h1>Making input fields "Angular"</h1>
					<p>Basically, you can replace JSF EL expressions by AngularJS mustaches almost everywhere in your code. If you do, 
					the JSF bean is read and replicated on the client. It's part of the AngularJS model. So you can use the same value in a JSF bean
					and as a AngularJS model attribute. Even better, you can use both variables in a very similar way.</p> 
					<p>Let's have a look at the customer contact form we've been developing in the previous steps:</p>
					
					<script type="syntaxhighlighter" class="brush: xml"><![CDATA[
<prime:panel header="Contact information">
	<prime:panelGrid columns="3">
		<prime:inputText value="#{customer.lastName}" />
		<prime:inputText value="#{customer.firstName}" />
		<prime:inputText value="#{customer.dateOfBirth}" />
		<prime:inputText value="#{customer.emailAddress}" />
		<prime:selectBooleanCheckbox value="#{customer.IAgreeToTheTermsAndConditions}" />
	</prime:panelGrid>
	<prime:commandButton value="save" update="angular" action="#{customer.save}" />
</prime:panel>
					]]></script>
					<p>This is a traditional JSF page that doesn't make use of the AngularJS model. There's a small main.js file, but it's only needed to provide
					the client side widgets of AngularFaces and the client side bean validation (see step 5).</p>
					<p>Making this form's data available to AngularJS is as simple as can be: just replace the JSF EL terms #{...} by AngularJS style mustaches {{...}}:</p>
					<script type="syntaxhighlighter" class="brush: xml"><![CDATA[
<prime:panel header="Contact information">
	<prime:panelGrid columns="3">
		<prime:inputText value="{{customer.lastName}}" />
		<prime:inputText value="{{customer.firstName}}" />
		<prime:inputText value="{{customer.dateOfBirth}}" />
		<prime:inputText value="{{customer.emailAddress}}" />
		<prime:selectBooleanCheckbox value="{{customer.IAgreeToTheTermsAndConditions}}" />
	</prime:panelGrid>
	<prime:commandButton value="save" update="angular" action="#{customer.save}" />
</prime:panel>
					]]></script>
					<p>On the JSF side, the mustache expressions are converted to ordinary JSF expressions. It doesn't matter wether
					you write {{customer.lastName}} or #{customer.lastName}, until you look at the Javascript code.</p>
					<p>On the AngularJS side, the bean attributes are added to the AngularJS scope. Hence there's a customer object,
					consisting of the first and last name, the date of birth and so on. For instance, you could use two AngularJS watches
					to suggest an email address:</p>
					<script type="syntaxhighlighter" class="brush: js"><![CDATA[
function LabelDemoController($scope) {
	// This initializes the Angular Model with the values of the JSF bean attributes
	initJSFScope($scope);

	$scope.$watch('customer.lastName', function(newValue, oldValue) {
		if ($scope.customer.firstName!="" && $scope.customer.lastName!="") {
			var name = "".concat($scope.customer.firstName).concat(".").concat($scope.customer.lastName);
			$scope.customer.emailAddress = name + "@example.com";
		}
	});
	$scope.$watch('customer.firstName', function(newValue, oldValue) {
		if ($scope.customer.firstName!="" && $scope.customer.lastName!="") {
			var name = "".concat($scope.customer.firstName).concat(".").concat($scope.customer.lastName);
			$scope.customer.emailAddress = name + "@example.com";
		}
	});

}]]></script>
					<p>Synchronizing values between AngularJS scope and JSF beans works in both ways. The values of the input fields are transmitted back to the
					server, no matter whether you do a regular HTML request, a JSF AJAX request or the optimized AngularFaces request.</p>
					<p>AngularFaces provides an advanced way of AJAX requests. Typically, they use a lot less network bandwidth, and they are faster than traditional
					JSF AJAX request. To activate an AngularFaces AJAX, you have to do two simple preparations:
					<ul>
					<li>Add an JSF AJAX button that includes a special update region: "angular". You've already seen this above: 
										<script type="syntaxhighlighter" class="brush: xml"><![CDATA[
	<prime:commandButton value="save" update="angular" action="#{customer.save}" />]]></script>
					</li>
					<li>Add the id "angular" to the &lt;h:body&gt;.
					<script type="syntaxhighlighter" class="brush: xml"><![CDATA[
	<h:body ng-app="AngularFacesExamples" ng-controller="MyCtrl" id="angular">]]></script>
					</li>
					</ul>
					</p>
					<p>
					Note that the id "angular" doesn't really mark an ordinary update region. It's a virtual id. If AngularFaces sees the idea, it replaces the default
					update response generated by JSF by a highly-optimized response that updates only the scope values. However, there are also drawbacks to this approach.
					For instance, the &lt;h:messages&gt; tag isn't updated. Nor is &lt;prime:growl&gt;. I don't consider this a disadvantage: the idea of AngularFaces
					is to move such functionality to the client. Validation and presenting error messages in particular is Angular's job.
					</p>
					<br />
					<br />
					<br />



				</div>
			</div>
		</div>
	</section>

	<footer class="footer"
		style="position: fixed; bottom: 0px; width: 100%; background-color: #000; padding: 10px; color: #777">
		<span class="col-md-2"></span> <span class="col-md-4"> (C) 2014
			by Stephan Rauh (<a href="http://www.beyondjava.net">http://www.beyondjava.net</a>).
		</span> <span class="col-md-4"> Page design inspired by <a target="#"
			href="https://angularjs.org/">https://angularjs.org/</a>.
		</span>
	<span class="col-md-2">Legal notes:<a target="#" href="http://www.angularfaces.com/tutorial/legal/disclaimer.html">disclaimer</a> and <a target="#" href="http://www.angularfaces.com/tutorial/legal/impressum.html">impressum</a>. </span> </footer>
	</div>


</body>
</html>